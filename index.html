<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zarnox - Galactic Gold Rush!</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="Zarnox: Galactic Gold Rush! - A thrilling space shooter game where you destroy aliens, collect gold, and upgrade your spaceship. Survive endless waves and defeat giant bosses!">
    <meta name="keywords" content="Zarnox, Galactic Gold Rush, space shooter, alien game, spaceship game, arcade, action, gold collection, upgrades, boss fight, free game, online game">
    <meta name="author" content="Zenora AI">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background for space theme */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0; /* Remove padding from body to allow full screen game */
            box-sizing: border-box;
            color: #e2e8f0; /* Light text color */
            /* Removed overflow: hidden; to allow scrolling on mobile */
            background-image: url('https://i.ibb.co/CpNDPHHG/Gemini-Generated-Image-rqajpfrqajpfrqaj.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a202c;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e2e8f0;
            font-size: 2.5rem;
            font-weight: 800;
            z-index: 1000;
            transition: opacity 1s ease-out;
            background-image: url('https://i.ibb.co/CpNDPHHG/Gemini-Generated-Image-rqajpfrqajpfrqaj.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        .preloader-hidden {
            opacity: 0;
            pointer-events: none;
        }

        .preloader-watermark {
            font-size: 0.8rem;
            margin-top: 10px;
            color: #a0aec0;
        }

        .game-wrapper {
            background-color: rgba(45, 55, 72, 0.9); /* Darker gray with transparency */
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            padding: 2rem;
            text-align: center;
            max-width: 1000px; /* Wider for game + upgrades */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative; /* For footer */
            z-index: 1; /* Ensure it's above background */
            /* Allow scrolling for the main menu content if it overflows on small screens */
            max-height: 100vh; /* Limit height to viewport */
            overflow-y: auto; /* Enable vertical scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }

        .game-screen.hidden {
            transform: translateY(100vh);
            opacity: 0;
            pointer-events: none;
            position: absolute; /* Take it out of flow when hidden */
        }

        .game-active-full-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #1a202c; /* Dark background for space theme */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Align items to top */
            align-items: center;
            padding: 0;
            margin: 0;
            z-index: 50; /* Above main menu, below preloader */
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }

        .game-active-full-screen .game-stats {
            width: 100%;
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.5);
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            position: fixed;
            top: 0;
            left: 0;
            z-index: 60;
        }

        .game-active-full-screen canvas {
            margin-top: 70px; /* Space for header */
        }

        canvas {
            background-color: #000000; /* Black for space */
            border: 2px solid #4a5568; /* Subtle border */
            border-radius: 0.75rem;
            display: block;
            margin: 0 auto;
            touch-action: none; /* Disable default touch actions like scrolling/zooming */
            width: 100%; /* Make canvas responsive */
            max-width: 600px; /* Max width for desktop */
            height: auto; /* Maintain aspect ratio */
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: #cbd5e0;
        }

        .upgrade-section, .items-section {
            background-color: rgba(44, 62, 80, 0.9); /* Slightly different dark shade with transparency */
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .upgrade-buttons, .item-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .upgrade-button, .item-button {
            background-color: #4a90e2; /* Blue for upgrades */
            color: white;
            font-weight: 700;
            padding: 0.8rem 1.2rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .upgrade-button:hover:not(:disabled), .item-button:hover:not(:disabled) {
            background-color: #357ABD;
            transform: translateY(-3px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }

        .upgrade-button:disabled, .item-button:disabled {
            background-color: #4a5568; /* Gray out when disabled */
            cursor: not-allowed;
            opacity: 0.7;
        }

        .start-button {
            background-color: #48bb78; /* Green for start */
            color: white;
            font-weight: 800;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .start-button:hover {
            background-color: #38a169;
            transform: translateY(-3px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }

        .message-box {
            background-color: #fefcbf;
            border: 1px solid #fbd38d;
            color: #975a16;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            font-weight: 600;
            display: none;
            word-wrap: break-word; /* Ensure text wraps */
        }

        .message-box.show {
            display: block;
        }

        .footer {
            margin-top: 2rem;
            text-align: center;
            color: #a0aec0;
            font-size: 0.9rem;
            position: relative;
            bottom: 0;
            width: 100%;
            padding: 1rem 0;
        }

        .footer img {
            height: 30px; /* Adjust as needed */
            vertical-align: middle;
            margin-left: 10px;
        }

        /* Ship selection and stats display */
        .ship-selection {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .ship-image-container {
            width: 100px; /* Fixed width for ship image */
            height: 100px; /* Fixed height for ship image */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease-in-out;
        }

        .ship-image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .ship-stats-display {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: left;
            flex-grow: 1;
            max-width: 300px;
        }

        .ship-stats-display p {
            margin-bottom: 0.5rem;
        }

        .ship-nav-button {
            background-color: #63b3ed;
            color: white;
            font-weight: 700;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .ship-nav-button:hover:not(:disabled) {
            background-color: #4299e1;
        }

        .ship-nav-button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .redeem-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
            align-items: center;
        }

        .redeem-input {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            width: 80%;
            max-width: 250px;
        }

        .redeem-button {
            background-color: #ed8936; /* Orange for redeem */
            color: white;
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .redeem-button:hover {
            background-color: #dd6b20;
            transform: translateY(-2px);
        }

        .buy-coins-button {
            background-color: #ecc94b; /* Yellow for buy coins */
            color: #2d3748;
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            text-decoration: none; /* For anchor tag */
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .buy-coins-button:hover {
            background-color: #d69e2e;
            transform: translateY(-2px);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-wrapper {
                padding: 1.5rem;
                gap: 1rem;
            }
            .game-stats {
                font-size: 1.1rem;
                gap: 0.75rem;
            }
            .upgrade-section, .items-section {
                padding: 1rem;
            }
            .upgrade-button, .item-button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            h1 {
                font-size: 2rem;
            }
            .ship-selection {
                flex-direction: column;
            }
            .ship-stats-display {
                width: 100%;
                max-width: none;
            }
            .redeem-input {
                width: 90%;
            }
        }

        @media (max-width: 480px) {
            .game-wrapper {
                padding: 1rem;
            }
            h1 {
                font-size: 1.75rem;
            }
            .game-stats {
                font-size: 1rem;
                flex-direction: column;
            }
            .upgrade-buttons, .item-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            .upgrade-button, .item-button {
                width: 100%;
            }
            .preloader {
                font-size: 1.8rem;
            }
            .preloader-watermark {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen">
    <!-- Preloader -->
    <div id="preloader" class="preloader">
        ZARNOX
        <div class="preloader-watermark">Powered by <a href="https://zenora-ai.vercel.app/" target="_blank" class="text-blue-400 hover:underline">Zenora AI</a></div>
        <div class="mt-4 text-sm">Loading assets...</div>
    </div>

    <!-- Main Game Wrapper -->
    <div id="gameWrapper" class="game-wrapper">
        <h1 class="text-4xl font-extrabold text-white mb-4">Zarnox: Galactic Gold Rush!</h1>

        <div class="game-stats">
            <span>Score: <span id="scoreDisplay">0</span></span>
            <span>Gold: <span id="goldDisplay">0</span> 💰</span>
            <span>Health: <span id="healthDisplay">2000</span> ❤️</span>
        </div>

        <!-- Game Canvas and Controls -->
        <div id="gameScreen" class="game-screen">
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <button id="startButton" class="start-button">Start Game</button>
            <div id="messageBox" class="message-box">
                Welcome, pilot! Destroy aliens, collect gold, and upgrade your ship! Use A/D or Left/Right arrows to move. Your ship shoots automatically!
            </div>
        </div>

        <!-- Upgrade Section -->
        <div class="upgrade-section">
            <h2 class="text-2xl font-bold text-white mb-3">Ship Upgrades</h2>

            <!-- Ship Selection and Stats -->
            <div class="ship-selection">
                <button id="prevShipBtn" class="ship-nav-button">←</button>
                <div class="flex flex-col items-center gap-2">
                    <div class="ship-image-container">
                        <img id="currentShipImage" src="" alt="Current Ship">
                    </div>
                    <span id="currentShipName" class="text-xl font-bold text-white"></span>
                </div>
                <div class="ship-stats-display">
                    <p>Health: <span id="shipBaseHealth"></span></p>
                    <p>Firepower: <span id="shipBaseFirepower"></span></p>
                    <p>Speed: <span id="shipBaseSpeed"></span></p>
                    <p>Size: <span id="shipBaseSize"></span></p>
                </div>
                <button id="nextShipBtn" class="ship-nav-button">→</button>
            </div>
            <button id="upgradeShipTierBtn" class="upgrade-button mb-4">
                Upgrade to Next Ship (<span id="shipTierCost"></span> 💰)
            </button>

            <h3 class="text-xl font-bold text-white mb-2">Individual Ship Enhancements (Max 3 per stat)</h3>
            <div class="upgrade-buttons">
                <button id="upgradeHealthBtn" class="upgrade-button">
                    Health <span id="healthLevel">(0/3)</span> (<span id="healthCost">50</span> 💰)
                </button>
                <button id="upgradeFirepowerBtn" class="upgrade-button">
                    Firepower <span id="firepowerLevel">(0/3)</span> (<span id="firepowerCost">75</span> 💰)
                </button>
                <button id="upgradeSpeedBtn" class="upgrade-button">
                    Speed <span id="speedLevel">(0/3)</span> (<span id="speedCost">60</span> 💰)
                </button>
                <button id="upgradeSizeBtn" class="upgrade-button">
                    Size <span id="sizeLevel">(0/3)</span> (<span id="sizeCost">100</span> 💰)
                </button>
                <button id="upgradeFireRateBtn" class="upgrade-button">
                    Fire Rate <span id="fireRateLevel">(0/3)</span> (<span id="fireRateCost">90</span> 💰)
                </button>
            </div>
        </div>

        <!-- Items Section -->
        <div class="items-section">
            <h2 class="text-2xl font-bold text-white mb-3">Items</h2>
            <div class="item-buttons">
                <button id="buyCloneBtn" class="item-button">
                    Buy Clone (<span id="cloneCost">200</span> 💰)
                </button>
                <button id="useCloneBtn" class="item-button">
                    Use Clone (<span id="cloneCount">0</span>)
                </button>
                <button id="buyShieldBtn" class="item-button">
                    Buy Shield (<span id="shieldCost">150</span> 💰)
                </button>
                <button id="useShieldBtn" class="item-button">
                    Use Shield (<span id="shieldCount">0</span>)
                </button>
                <button id="buyBombBtn" class="item-button">
                    Buy Bomb (<span id="bombCost">300</span> 💰)
                </button>
                <button id="useBombBtn" class="item-button">
                    Use Bomb (<span id="bombCount">0</span>)
                </button>
                <button id="buyTimeWarpBtn" class="item-button">
                    Buy Time Warp (<span id="timeWarpCost">100</span> 💰)
                </button>
                <button id="useTimeWarpBtn" class="item-button">
                    Use Time Warp (<span id="timeWarpCount">0</span>)
                </button>
            </div>
        </div>

        <!-- Buy Coins and Redeem Code Section -->
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mt-4">
            <a href="https://tally.so/r/3x7Bl5" target="_blank" class="buy-coins-button">
                Buy Coins Online
            </a>
            <div class="redeem-section">
                <input type="text" id="redeemCodeInput" class="redeem-input" placeholder="Enter Redeem Code">
                <button id="redeemCodeBtn" class="redeem-button">Redeem Code</button>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            Zarnox - Galactic Gold Rush! &copy; 2024
            <img src="https://i.ibb.co/JRsMXc4G/Gemini-Generated-Image-gyfxkzgyfxkzgyfx.png" alt="Website Logo">
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const preloader = document.getElementById('preloader');
        const gameWrapper = document.getElementById('gameWrapper');
        const gameScreen = document.getElementById('gameScreen');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const goldDisplay = document.getElementById('goldDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const startButton = document.getElementById('startButton');
        const messageBox = document.getElementById('messageBox');

        const upgradeHealthBtn = document.getElementById('upgradeHealthBtn');
        const upgradeFirepowerBtn = document.getElementById('upgradeFirepowerBtn');
        const upgradeSpeedBtn = document.getElementById('upgradeSpeedBtn');
        const upgradeSizeBtn = document.getElementById('upgradeSizeBtn');
        const upgradeFireRateBtn = document.getElementById('upgradeFireRateBtn');
        const upgradeShipTierBtn = document.getElementById('upgradeShipTierBtn');

        const healthCostDisplay = document.getElementById('healthCost');
        const firepowerCostDisplay = document.getElementById('firepowerCost');
        const speedCostDisplay = document.getElementById('speedCost');
        const sizeCostDisplay = document.getElementById('sizeCost');
        const fireRateCostDisplay = document.getElementById('fireRateCost');
        const shipTierCostDisplay = document.getElementById('shipTierCost');

        const healthLevelDisplay = document.getElementById('healthLevel');
        const firepowerLevelDisplay = document.getElementById('firepowerLevel');
        const speedLevelDisplay = document.getElementById('speedLevel');
        const sizeLevelDisplay = document.getElementById('sizeLevel');
        const fireRateLevelDisplay = document.getElementById('fireRateLevel');

        const currentShipImage = document.getElementById('currentShipImage');
        const currentShipName = document.getElementById('currentShipName');
        const shipBaseHealth = document.getElementById('shipBaseHealth');
        const shipBaseFirepower = document.getElementById('shipBaseFirepower');
        const shipBaseSpeed = document.getElementById('shipBaseSpeed');
        const shipBaseSize = document.getElementById('shipBaseSize');
        const prevShipBtn = document.getElementById('prevShipBtn');
        const nextShipBtn = document.getElementById('nextShipBtn');

        const redeemCodeInput = document.getElementById('redeemCodeInput');
        const redeemCodeBtn = document.getElementById('redeemCodeBtn'); 

        // Item related DOM elements
        const buyCloneBtn = document.getElementById('buyCloneBtn');
        const useCloneBtn = document.getElementById('useCloneBtn');
        const cloneCostDisplay = document.getElementById('cloneCost');
        const cloneCountDisplay = document.getElementById('cloneCount');

        const buyShieldBtn = document.getElementById('buyShieldBtn');
        const useShieldBtn = document.getElementById('useShieldBtn');
        const shieldCostDisplay = document.getElementById('shieldCost');
        const shieldCountDisplay = document.getElementById('shieldCount');

        const buyBombBtn = document.getElementById('buyBombBtn');
        const useBombBtn = document.getElementById('useBombBtn');
        const bombCostDisplay = document.getElementById('bombCost');
        const bombCountDisplay = document.getElementById('bombCount');

        const buyTimeWarpBtn = document.getElementById('buyTimeWarpBtn');
        const useTimeWarpBtn = document.getElementById('useTimeWarpBtn');
        const timeWarpCostDisplay = document.getElementById('timeWarpCost');
        const timeWarpCountDisplay = document.getElementById('timeWarpCount');


        // --- Game State Variables ---
        let gameActive = false;
        let score = 0;
        let gold = 0;
        let player = {}; // Player object
        let playerClones = []; // Array to hold active player clones
        let bullets = []; // Array to hold active player bullets
        let alienBullets = []; // Array to hold active alien bullets
        let aliens = []; // Array to hold active aliens
        let coins = []; // Array to hold active coins
        let powerups = []; // Array to hold active power-ups
        let boss = null; // Boss object
        let bossLasers = []; // Array to hold active boss lasers

        let keys = {}; // Object to track pressed keys for smooth movement
        let inGameMessages = []; // Array to hold floating in-game messages

        // Game difficulty and spawning
        let currentWave = 0;
        const ALIENS_PER_WAVE = 5; // Number of aliens per regular wave
        let aliensSpawnedInWave = 0;
        let aliensDestroyedInWave = 0;
        let alienSpawnInterval = 1500; // Milliseconds between alien spawns
        let lastAlienSpawnTime = 0;
        let gameSpeedMultiplier = 1; // Increases over time for difficulty
        const BOSS_WAVE_INTERVAL = 5; // Boss appears every 5th wave

        // Upgrade costs and levels
        const UPGRADE_BASE_COST = {
            health: 50,
            firepower: 75,
            speed: 60,
            size: 100,
            fireRate: 90
        };
        const UPGRADE_COST_MULTIPLIER = 1.5; // Cost increases by this factor each level
        const MAX_INDIVIDUAL_UPGRADE_LEVEL = 3; // Max levels for health, firepower, speed, size, fireRate

        let upgradeLevels = {
            health: 0,
            firepower: 0,
            speed: 0,
            size: 0,
            fireRate: 0
        };
        let currentShipTier = 0; // Index of the current ship tier

        // Item Data and Inventory
        const ITEMS = {
            clone: { cost: 200, duration: 7000 },
            shield: { cost: 150, duration: 7000 },
            bomb: { cost: 300, duration: 0 }, // Bomb is instant, no duration
            timeWarp: { cost: 100, duration: 7000 }
        };
        let inventory = {
            clone: 0,
            shield: 0,
            bomb: 0,
            timeWarp: 0
        };
        let activeEffects = {
            shield: false,
            timeWarp: false,
            clone: false, // Tracks if clone effect is active (not if clone exists)
            magnetron: false,
            solarFlame: false,
            repairDrone: false,
            frostPulse: false,
            plasmaBlaster: false,
            hyperSurge: false
        };
        let effectTimers = {
            shield: null,
            timeWarp: null,
            clone: null,
            magnetron: null,
            solarFlame: null,
            repairDrone: null,
            frostPulse: null,
            plasmaBlaster: null,
            hyperSurge: null
        };
        let repairDroneInterval = null;


        // Ship Tier Data
        const SHIP_TIERS = [
            {
                name: "Scout",
                image: 'https://i.ibb.co/Zp91vZM1/Add-a-subheading-3-removebg-preview.png',
                baseHealth: 2000,
                baseFirepower: 10,
                baseSpeed: 5,
                baseWidth: 40,
                baseHeight: 40,
                baseFireRate: 300,
                cost: 0 // Starting ship
            },
            {
                name: "Interceptor",
                image: 'https://i.ibb.co/5gN4kQPm/Add-a-subheading-4-removebg-preview.png',
                baseHealth: 2500,
                baseFirepower: 15,
                baseSpeed: 6,
                baseWidth: 45,
                baseHeight: 45,
                baseFireRate: 250,
                cost: 1000 // Cost to upgrade to this ship
            },
            {
                name: "Vanguard",
                image: 'https://i.ibb.co/XxxmMMYG/Add-a-subheading-5-removebg-preview.png',
                baseHealth: 3000,
                baseFirepower: 20,
                baseSpeed: 7,
                baseWidth: 50,
                baseHeight: 50,
                baseFireRate: 200,
                cost: 5000
            },
            {
                name: "Dreadnought",
                image: 'https://i.ibb.co/ns63zjhR/Add-a-subheading-6-removebg-preview.png',
                baseHealth: 4000,
                baseFirepower: 30,
                baseSpeed: 8,
                baseWidth: 60,
                baseHeight: 60,
                baseFireRate: 150,
                cost: 15000
            },
            {
                name: "Titan",
                image: 'https://i.ibb.co/0yBxnkXc/Add-a-subheading-7-removebg-preview.png',
                baseHealth: 5000,
                baseFirepower: 40,
                baseSpeed: 9,
                baseWidth: 70,
                baseHeight: 70,
                baseFireRate: 100,
                cost: 30000
            },
            {
                name: "Cosmic Destroyer",
                image: 'https://i.ibb.co/LmryyQX/Add-a-subheading-8-removebg-preview.png',
                baseHealth: 7000,
                baseFirepower: 50,
                baseSpeed: 10,
                baseWidth: 80,
                baseHeight: 80,
                baseFireRate: 75,
                cost: 50000
            }
        ];

        // Alien Images
        const ALIEN_IMAGES = [
            'https://i.ibb.co/H1wtjD3/21-removebg-preview.png',
            'https://i.ibb.co/qYZDjdYK/22-removebg-preview.png',
            'https://i.ibb.co/Sk0S6Ln/23-removebg-preview.png',
            'https://i.ibb.co/nZMTxSJ/24-removebg-preview.png',
            'https://i.ibb.co/5WmmmJBg/25-removebg-preview.png',
            'https://i.ibb.co/bMfTXBPs/26-removebg-preview.png'
        ];

        // Boss Images
        const BOSS_IMAGES = [
            'https://i.ibb.co/60tHqjVH/29-removebg-preview.png',
            'https://i.ibb.co/yc594vt1/28-removebg-preview.png',
            'https://i.ibb.co/cSGZdHtc/30-removebg-preview.png',
            'https://i.ibb.co/5WyDghFc/27-removebg-preview.png',
            'https://i.ibb.co/tTV2TGgB/32-removebg-preview.png',
            'https://i.ibb.co/FT0nGkd/31-removebg-preview.png'
        ];

        // Preload all images
        const ASSET_URLS = [
            ...SHIP_TIERS.map(ship => ship.image),
            ...ALIEN_IMAGES,
            ...BOSS_IMAGES,
            'https://i.ibb.co/CpNDPHHG/Gemini-Generated-Image-rqajpfrqajpfrqaj.png', // Background
            'https://i.ibb.co/JRsMXc4G/Gemini-Generated-Image-gyfxkzgyfxkzgyfx.png' // Footer Logo
        ];
        const loadedAssets = {};

        function preloadAssets() {
            let loadedCount = 0;
            const totalAssets = ASSET_URLS.length;

            return new Promise((resolve) => {
                ASSET_URLS.forEach(url => {
                    const img = new Image();
                    img.src = url;
                    img.onload = () => {
                        loadedAssets[url] = img;
                        loadedCount++;
                        if (loadedCount === totalAssets) {
                            resolve();
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load image: ${url}`);
                        loadedCount++; // Still count it to avoid infinite loading
                        if (loadedCount === totalAssets) {
                            resolve();
                        }
                    };
                });
            });
        }

        // --- Game Entities (Classes) ---

        /**
         * Base class for game objects that have position, dimensions, and an image.
         */
        class GameObject {
            constructor(x, y, width, height, imageSrc) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.image = loadedAssets[imageSrc]; // Use preloaded image
            }

            /**
             * Draws the object on the canvas.
             * If image is not loaded, draw a fallback rectangle.
             */
            draw() {
                if (this.image && this.image.complete) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'gray'; // Fallback color
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        /**
         * Represents the player's spaceship.
         */
        class Player extends GameObject {
            constructor(shipTierData) {
                super(
                    canvas.width / 2 - shipTierData.baseWidth / 2,
                    canvas.height - shipTierData.baseHeight - 20,
                    shipTierData.baseWidth,
                    shipTierData.baseHeight,
                    shipTierData.image
                );
                this.baseSpeed = shipTierData.baseSpeed;
                this.speed = this.baseSpeed;
                this.baseHealth = shipTierData.baseHealth;
                this.health = this.baseHealth;
                this.maxHealth = this.baseHealth; // Max health for health bar
                this.baseFirepower = shipTierData.baseFirepower; // Damage per bullet
                this.firepower = this.baseFirepower;
                this.baseFireRate = shipTierData.baseFireRate; // Milliseconds between shots
                this.fireRate = this.baseFireRate;
                this.lastShotTime = 0;
                this.isInvincible = false; // For power-ups
                this.rapidFireActive = false; // For power-ups (now part of hyper_surge/plasma_blaster)
                this.rapidFireEndTime = 0;
            }

            /**
             * Draws the player on the canvas, including a health bar.
             */
            draw() {
                super.draw();
                this.drawHealthBar();
                // Draw solar flame effect if active
                if (activeEffects.solarFlame) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.2 * Math.sin(Date.now() / 100); // Pulsing effect
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            /**
             * Draws the player's health bar above the ship.
             */
            drawHealthBar() {
                const barWidth = this.width;
                const barHeight = 5;
                const barX = this.x;
                const barY = this.y - barHeight - 5; // 5 pixels above the ship

                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = 'green';
                const currentHealthWidth = barWidth * (this.health / this.maxHealth);
                ctx.fillRect(barX, barY, currentHealthWidth, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            /**
             * Updates player position based on key presses.
             */
            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5; // Slower if time warp active
                if (activeEffects.hyperSurge) currentSpeed *= 2; // Faster if hyper surge active

                if (keys['ArrowLeft'] || keys['a']) {
                    this.x -= currentSpeed;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    this.x += currentSpeed;
                }

                // Keep player within canvas bounds
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Check rapid fire duration (now part of plasma_blaster/hyper_surge)
                if ((activeEffects.plasmaBlaster || activeEffects.hyperSurge) && Date.now() > this.rapidFireEndTime) {
                    this.rapidFireActive = false; // This flag is used internally for fire rate calculation
                    activeEffects.plasmaBlaster = false;
                    activeEffects.hyperSurge = false;
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Power-up ended!", 'white'));
                    // Reapply base speed/firepower/fireRate after power-up ends
                    applyUpgrades();
                }
            }

            /**
             * Creates a new bullet and adds it to the bullets array.
             */
            shoot() {
                bullets.push(new Bullet(this.x + this.width / 2 - 5, this.y, this.firepower));
            }

            /**
             * Reduces player health.
             * @param {number} damage The amount of damage to take.
             */
            takeDamage(damage) {
                if (this.isInvincible || activeEffects.shield) return; // Don't take damage if invincible or shield active

                this.health -= damage;
                if (this.health <= 0) {
                    this.health = 0;
                    gameOver(); // Call the global gameOver function
                }
                updateUI();
                inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, `-${damage} HP!`, 'red'));
            }

            /**
             * Heals the player up to max health.
             * @param {number} amount The amount to heal.
             */
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                updateUI();
                inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, `+${amount} HP!`, 'green'));
            }

            /**
             * Sets player invincibility for a duration.
             * @param {number} durationMs Duration in milliseconds.
             */
            setInvincibility(durationMs) {
                this.isInvincible = true;
                inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Invincible!", 'cyan'));
                clearTimeout(effectTimers.shield); // Clear any existing shield timer
                effectTimers.shield = setTimeout(() => {
                    this.isInvincible = false;
                    activeEffects.shield = false; // Also turn off shield effect
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Invincibility ended!", 'white'));
                }, durationMs);
            }

            /**
             * Activates rapid fire for a duration.
             * @param {number} durationMs Duration in milliseconds.
             */
            activateRapidFire(durationMs) {
                this.rapidFireActive = true;
                this.rapidFireEndTime = Date.now() + durationMs;
                inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Rapid Fire!", 'yellow'));
            }
        }

        /**
         * Represents a player clone ship.
         */
        class PlayerClone extends Player {
            constructor(shipTierData, offsetX) {
                super(shipTierData);
                this.x = player.x + offsetX; // Position relative to player
                this.y = player.y;
                this.isClone = true;
                this.lastShotTime = Date.now(); // Start shooting immediately
            }

            update() {
                // Clones follow the player's X position
                this.x = player.x + (this.isClone ? (this.width + 10) * (this.x < player.x ? -1 : 1) : 0); // Simple follow logic
                this.y = player.y; // Stay at player's Y

                // Keep clone within canvas bounds
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Auto-shoot
                const currentFireRate = (activeEffects.plasmaBlaster || activeEffects.hyperSurge) ? this.fireRate / 2 : this.fireRate;
                if (Date.now() - this.lastShotTime > currentFireRate) {
                    this.shoot();
                    this.lastShotTime = Date.now();
                }
            }
            // Clones don't take damage or have health bars
            drawHealthBar() {}
            takeDamage() {}
            heal() {}
            setInvincibility() {}
            activateRapidFire() {}
        }


        /**
         * Represents a bullet fired by the player.
         */
        class Bullet extends GameObject {
            constructor(x, y, damage) {
                super(x, y, 10, 20, null); // No image for bullet, draw emoji
                this.speed = 15;
                this.damage = damage;
                this.emoji = '⚡';
                if (activeEffects.plasmaBlaster) {
                    this.emoji = '💥'; // Plasma effect
                    this.damage *= 1.5; // Plasma blaster deals more damage
                    this.width = 15;
                    this.height = 30;
                }
            }

            draw() {
                ctx.font = `${this.height}px Arial`;
                ctx.fillText(this.emoji, this.x, this.y);
            }

            /**
             * Updates the bullet's position.
             */
            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5; // Slower if time warp active
                if (activeEffects.frostPulse) currentSpeed *= 0.5; // Slower if frost pulse active (for alien bullets)
                this.y -= currentSpeed;
            }
        }

        /**
         * Represents a bullet fired by an alien.
         */
        class AlienBullet extends GameObject {
            constructor(x, y, damage, targetX) {
                super(x, y, 8, 15, null); // Smaller alien bullet
                this.speed = 7;
                this.damage = damage;
                this.emoji = '🔴'; // Red circle emoji for alien bullet
                this.targetX = targetX;
                this.targetY = canvas.height; // Always target bottom of screen
                this.dx = (this.targetX - this.x);
                this.dy = (this.targetY - this.y);
                this.distance = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                this.vx = (this.dx / this.distance) * this.speed;
                this.vy = (this.dy / this.distance) * this.speed;
            }

            draw() {
                ctx.font = `${this.height}px Arial`;
                ctx.fillText(this.emoji, this.x, this.y);
            }

            update() {
                let currentSpeedMultiplier = 1;
                if (activeEffects.timeWarp) currentSpeedMultiplier *= 0.5; // Slower if time warp active
                if (activeEffects.frostPulse) currentSpeedMultiplier *= 0.5; // Slower if frost pulse active

                this.x += this.vx * currentSpeedMultiplier;
                this.y += this.vy * currentSpeedMultiplier;
            }
        }

        /**
         * Represents an alien enemy.
         */
        class Alien extends GameObject {
            constructor(x, y, level) {
                const alienImageIndex = Math.min(level, ALIEN_IMAGES.length - 1);
                const imageSrc = ALIEN_IMAGES[alienImageIndex];
                const width = 35 + (level * 2); // Scale width with level
                const height = 35 + (level * 2); // Scale height with level
                super(x, y, width, height, imageSrc);

                // Difficulty scaling based on wave level (non-linear)
                this.baseSpeed = 1 + (level * 0.1) * Math.pow(1.08, level); // Speed increases with level, with a curve
                this.speed = this.baseSpeed * gameSpeedMultiplier;
                this.baseHealth = 20 * Math.pow(1.15, level); // Health increases with level, with a curve
                this.health = this.baseHealth;
                this.goldValue = 10 + (level * 2); // Gold value increases with level
                this.scoreValue = 100 + (level * 20); // Score value increases with level
                this.targetY = 50 + Math.random() * (canvas.height / 3); // Stop at random Y in top third
                this.isStopped = false;
                this.lastShotTime = Date.now();
                this.shootInterval = Math.max(250, 1500 - (level * 100)); // Aliens shoot faster with level, min 250ms
                this.attackDamage = 2 + Math.floor(level / 2); // Alien reduces health by 2 + (level/2)
            }

            /**
             * Draws the alien on the canvas.
             */
            draw() {
                super.draw();
                // Optionally draw health bar for aliens if desired, but for now just player/boss
            }

            /**
             * Updates the alien's position and behavior.
             */
            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5;
                if (activeEffects.frostPulse) currentSpeed *= 0.5; // Slower if frost pulse active

                if (!this.isStopped) {
                    this.y += currentSpeed;
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.isStopped = true;
                    }
                }

                if (this.isStopped && Date.now() - this.lastShotTime > this.shootInterval) {
                    // Aliens shoot towards the player's current X position
                    alienBullets.push(new AlienBullet(this.x + this.width / 2 - 4, this.y + this.height, this.attackDamage, player.x + player.width/2));
                    this.lastShotTime = Date.now();
                }
            }

            /**
             * Reduces alien health.
             * @param {number} damage The amount of damage to take.
             * @returns {boolean} True if the alien is destroyed, false otherwise.
             */
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    return true; // Alien destroyed
                }
                return false;
            }
        }

        /**
         * Represents a boss enemy.
         */
        class Boss extends GameObject {
            constructor(x, y, level) {
                const bossImageIndex = Math.min(level, BOSS_IMAGES.length - 1);
                const imageSrc = BOSS_IMAGES[bossImageIndex];
                const width = 100 + (level * 10); // Scale width with level
                const height = 100 + (level * 10); // Scale height with level
                super(x, y, width, height, imageSrc);

                // Difficulty scaling for boss (more aggressive curve)
                this.baseHealth = 500 * Math.pow(1.5, level); // Health increases significantly
                this.health = this.baseHealth;
                this.maxHealth = this.baseHealth;
                this.speed = 1; // Boss moves slower
                this.goldValue = 500 + (level * 100);
                this.scoreValue = 1000 + (level * 200);
                this.attackDamage = 10 + Math.floor(level * 5); // Boss reduces health significantly
                this.attackInterval = Math.max(200, 1000 - (level * 150)); // Boss attacks much faster
                this.lastAttackTime = Date.now();
                this.direction = 1; // 1 for right, -1 for left
                this.targetY = 50; // Boss stops at a fixed Y
            }

            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5;
                if (activeEffects.frostPulse) currentSpeed *= 0.5; // Slower if frost pulse active

                // Move down until targetY, then move horizontally
                if (this.y < this.targetY) {
                    this.y += currentSpeed;
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                    }
                } else {
                    this.x += currentSpeed * this.direction;
                    if (this.x + this.width > canvas.width || this.x < 0) {
                        this.direction *= -1; // Change direction
                        this.x = Math.max(0, Math.min(canvas.width - this.width, this.x)); // Clamp to bounds
                    }
                }

                // Boss laser attack (constant, unavoidable damage)
                if (Date.now() - this.lastAttackTime > this.attackInterval) {
                    bossLasers.push(new BossLaser(this.x + this.width / 2, this.y + this.height, this.attackDamage));
                    this.lastAttackTime = Date.now();
                }
            }

            draw() {
                super.draw();
                // Draw health bar for boss
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 15, this.width, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x, this.y - 15, this.width * (this.health / this.maxHealth), 5);
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    return true; // Boss destroyed
                }
                return false;
            }
        }

        /**
         * Represents a laser fired by the boss.
         */
        class BossLaser extends GameObject {
            constructor(x, y, damage) {
                super(x - 25, y, 50, canvas.height - y, null); // Wide laser from boss to bottom
                this.damage = damage;
                this.color = 'red';
                this.alpha = 0.8;
                this.duration = 500; // Laser visible for 0.5 seconds
                this.startTime = Date.now();
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha * (1 - (Date.now() - this.startTime) / this.duration); // Fade out
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.restore();
            }

            update() {
                // Laser doesn't move, just fades out
            }
        }


        /**
         * Represents a gold coin.
         */
        class Coin extends GameObject {
            constructor(x, y, value) {
                super(x, y, 25, 25, null); // No image for coin, draw emoji
                this.speed = 3;
                this.value = value;
                this.emoji = '💰';
            }

            draw() {
                ctx.font = `${this.height}px Arial`;
                ctx.fillText(this.emoji, this.x, this.y + this.height);
            }

            /**
             * Updates the coin's position.
             */
            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5;
                if (activeEffects.frostPulse) currentSpeed *= 0.5; // Slower if frost pulse active

                this.y += currentSpeed;

                // Magnetron pull effect
                if (activeEffects.magnetron) {
                    const dx = player.x + player.width / 2 - (this.x + this.width / 2);
                    const dy = player.y + player.height / 2 - (this.y + this.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const magnetRadius = 150; // Radius for magnet pull

                    if (distance < magnetRadius) {
                        const pullStrength = (magnetRadius - distance) / magnetRadius * 5; // Stronger pull closer
                        this.x += (dx / distance) * pullStrength;
                        this.y += (dy / distance) * pullStrength;
                    }
                }
            }
        }

        /**
         * Represents a power-up.
         */
        class PowerUp extends GameObject {
            constructor(x, y, type) {
                super(x, y, 30, 30, null); // No image for power-up, draw emoji
                this.speed = 2;
                this.type = type; // 'health', 'rapid_fire', 'invincibility', 'plasma_blaster', 'hyper_surge', 'magnetron_pull', 'solar_flame', 'repair_drone', 'frost_pulse'
                this.emoji = '';
                if (this.type === 'health') this.emoji = '❤️';
                else if (this.type === 'invincibility') this.emoji = '🛡️';
                else if (this.type === 'plasma_blaster') this.emoji = '🔫';
                else if (this.type === 'hyper_surge') this.emoji = '⚡';
                else if (this.type === 'magnetron_pull') this.emoji = '🧲';
                else if (this.type === 'solar_flame') this.emoji = '🔥';
                else if (this.type === 'repair_drone') this.emoji = '🛠️';
                else if (this.type === 'frost_pulse') this.emoji = '❄️';
            }

            draw() {
                ctx.font = `${this.height}px Arial`;
                ctx.fillText(this.emoji, this.x, this.y + this.height);
            }

            update() {
                let currentSpeed = this.speed;
                if (activeEffects.timeWarp) currentSpeed *= 0.5;
                if (activeEffects.frostPulse) currentSpeed *= 0.5; // Slower if frost pulse active

                this.y += currentSpeed;
            }

            applyEffect() {
                const DURATION = 7000; // 7 seconds for most power-ups
                if (this.type === 'health') {
                    player.heal(player.maxHealth * 0.2); // Heal 20% of max health
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Health Boost!", 'green'));
                } else if (this.type === 'invincibility') {
                    player.setInvincibility(DURATION); // 7 seconds of invincibility
                } else if (this.type === 'plasma_blaster') {
                    activeEffects.plasmaBlaster = true;
                    player.rapidFireEndTime = Date.now() + DURATION;
                    player.firepower *= 1.5; // 50% more damage
                    player.fireRate = Math.max(50, player.fireRate / 1.5); // 50% faster fire rate
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Plasma Blaster!", 'yellow'));
                    clearTimeout(effectTimers.plasmaBlaster);
                    effectTimers.plasmaBlaster = setTimeout(() => {
                        activeEffects.plasmaBlaster = false;
                        applyUpgrades(); // Reset player stats
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Plasma Blaster ended!", 'white'));
                    }, DURATION);
                } else if (this.type === 'hyper_surge') {
                    activeEffects.hyperSurge = true;
                    player.rapidFireEndTime = Date.now() + DURATION; // Reuse rapidFireEndTime for duration
                    player.speed *= 1.5; // 50% more speed
                    player.fireRate = Math.max(50, player.fireRate / 1.5); // 50% faster fire rate
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Hyper Surge!", 'orange'));
                    clearTimeout(effectTimers.hyperSurge);
                    effectTimers.hyperSurge = setTimeout(() => {
                        activeEffects.hyperSurge = false;
                        applyUpgrades(); // Reset player stats
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Hyper Surge ended!", 'white'));
                    }, DURATION);
                } else if (this.type === 'magnetron_pull') {
                    activeEffects.magnetron = true;
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Magnetron Pull!", 'purple'));
                    clearTimeout(effectTimers.magnetron);
                    effectTimers.magnetron = setTimeout(() => {
                        activeEffects.magnetron = false;
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Magnetron ended!", 'white'));
                    }, DURATION);
                } else if (this.type === 'solar_flame') {
                    activeEffects.solarFlame = true;
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Solar Flame!", 'red'));
                    clearTimeout(effectTimers.solarFlame);
                    effectTimers.solarFlame = setTimeout(() => {
                        activeEffects.solarFlame = false;
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Solar Flame ended!", 'white'));
                    }, DURATION);
                } else if (this.type === 'repair_drone') {
                    activeEffects.repairDrone = true;
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Repair Drone!", 'cyan'));
                    if (repairDroneInterval) clearInterval(repairDroneInterval);
                    repairDroneInterval = setInterval(() => {
                        player.heal(player.maxHealth * 0.02); // Heal 2% every second
                    }, 1000);
                    clearTimeout(effectTimers.repairDrone);
                    effectTimers.repairDrone = setTimeout(() => {
                        activeEffects.repairDrone = false;
                        clearInterval(repairDroneInterval);
                        repairDroneInterval = null;
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Repair Drone ended!", 'white'));
                    }, DURATION);
                } else if (this.type === 'frost_pulse') {
                    activeEffects.frostPulse = true;
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Frost Pulse!", 'blue'));
                    clearTimeout(effectTimers.frostPulse);
                    effectTimers.frostPulse = setTimeout(() => {
                        activeEffects.frostPulse = false;
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Frost Pulse ended!", 'white'));
                    }, DURATION);
                }
            }
        }

        /**
         * Represents a floating in-game message.
         */
        class InGameMessage {
            constructor(x, y, text, color = 'white', duration = 2000) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.alpha = 1.0;
                this.speedY = 0.5; // Moves upwards
                this.startTime = Date.now();
                this.duration = duration;
            }

            update() {
                this.y -= this.speedY;
                this.alpha = 1 - ((Date.now() - this.startTime) / this.duration);
                if (this.alpha < 0) this.alpha = 0;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }


        // --- Game Functions ---

        /**
         * Initializes or resets the game state.
         */
        function initializeGame() {
            gameActive = false;
            score = 0;
            gold = 0;
            bullets = [];
            alienBullets = [];
            aliens = [];
            coins = [];
            powerups = [];
            boss = null;
            bossLasers = [];
            playerClones = [];
            keys = {};
            inGameMessages = [];
            currentWave = 0;
            aliensSpawnedInWave = 0;
            aliensDestroyedInWave = 0;
            alienSpawnInterval = 1500;
            lastAlienSpawnTime = 0;
            gameSpeedMultiplier = 1;
            // Reset active effects and timers
            for (const key in activeEffects) {
                activeEffects[key] = false;
            }
            for (const key in effectTimers) {
                clearTimeout(effectTimers[key]);
                effectTimers[key] = null;
            }
            if (repairDroneInterval) {
                clearInterval(repairDroneInterval);
                repairDroneInterval = null;
            }


            // Reset upgrade levels and costs
            upgradeLevels = {
                health: 0,
                firepower: 0,
                speed: 0,
                size: 0,
                fireRate: 0
            };
            currentShipTier = 0; // Start with the first ship

            player = new Player(SHIP_TIERS[currentShipTier]); // Create new player instance with current tier
            applyUpgrades(); // Apply initial upgrades (none at start)

            updateUI();
            updateUpgradeButtonCosts();
            checkUpgradeButtonStates();
            updateShipDisplay();
            updateItemDisplay(); // Update item counts and button states
            showMessage("Welcome, pilot! Destroy aliens, collect gold, and upgrade your ship! Use A/D or Left/Right arrows to move. Your ship shoots automatically!", 'info');
            startButton.style.display = 'block';
            gameScreen.classList.remove('game-active-full-screen');
            gameScreen.classList.remove('hidden'); // Ensure game screen is visible initially
            gameWrapper.style.padding = '2rem'; // Restore padding for menu view
        }

        /**
         * Function to handle game over.
         */
        function gameOver() {
            gameActive = false;
            showMessage(`Game Over! Your Score: ${score}, Waves Completed: ${currentWave}, Gold Collected: ${gold} 💰`, 'danger');

            // Clear all game entities
            bullets = [];
            alienBullets = [];
            aliens = [];
            coins = [];
            powerups = [];
            boss = null;
            bossLasers = [];
            playerClones = [];
            inGameMessages = [];

            // Clear any active effects and timers
            for (const key in activeEffects) {
                activeEffects[key] = false;
            }
            for (const key in effectTimers) {
                clearTimeout(effectTimers[key]);
                effectTimers[key] = null;
            }
            if (repairDroneInterval) {
                clearInterval(repairDroneInterval);
                repairDroneInterval = null;
            }

            // Return to main menu after a short delay
            setTimeout(() => {
                initializeGame(); // Reset game state for a new game
            }, 3000); // 3 seconds before returning to menu
        }

        /**
         * Starts the main game loop.
         */
        function startGame() {
            gameActive = true;
            score = 0;
            gold = 0;
            bullets = [];
            alienBullets = [];
            aliens = [];
            coins = [];
            powerups = [];
            boss = null;
            bossLasers = [];
            playerClones = [];
            keys = {};
            inGameMessages = [];
            currentWave = 1; // Start with wave 1
            aliensSpawnedInWave = 0;
            aliensDestroyedInWave = 0;
            alienSpawnInterval = 1500;
            lastAlienSpawnTime = Date.now(); // Reset spawn timer
            gameSpeedMultiplier = 1;
            // Reset active effects and timers
            for (const key in activeEffects) {
                activeEffects[key] = false;
            }
            for (const key in effectTimers) {
                clearTimeout(effectTimers[key]);
                effectTimers[key] = null;
            }
            if (repairDroneInterval) {
                clearInterval(repairDroneInterval);
                repairDroneInterval = null;
            }


            // Re-initialize player with current ship tier's base stats and then apply individual upgrades
            player = new Player(SHIP_TIERS[currentShipTier]);
            applyUpgrades(); // Re-apply individual upgrades based on saved levels

            updateUI();
            updateUpgradeButtonCosts();
            checkUpgradeButtonStates();
            updateItemDisplay(); // Update item counts and button states
            messageBox.classList.remove('show');
            startButton.style.display = 'none';

            // Transition to full screen game view
            gameScreen.classList.add('game-active-full-screen');
            gameWrapper.style.padding = '0'; // Remove padding for full screen game
            resizeCanvas(); // Adjust canvas size to full screen
            window.addEventListener('resize', resizeCanvas); // Listen for resize events

            gameLoop(); // Start the game loop
        }

        /**
         * Resizes the canvas to fill the window.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 70; // Account for header
            // Reposition player if screen size changes drastically
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = canvas.height - player.height - 20;
        }

        /**
         * The main game loop, updates game state and redraws elements.
         */
        function gameLoop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            const currentTime = Date.now();

            // --- Player Update ---
            player.update();
            player.draw();

            // --- Player Clones Update ---
            for (let i = playerClones.length - 1; i >= 0; i--) {
                const clone = playerClones[i];
                clone.update();
                clone.draw();
            }

            // --- Automatic Player Shooting ---
            const currentFireRate = (activeEffects.plasmaBlaster || activeEffects.hyperSurge) ? player.fireRate / 2 : player.fireRate;
            if (Date.now() - player.lastShotTime > currentFireRate) {
                player.shoot();
                player.lastShotTime = Date.now();
            }

            // --- Bullet Updates (Player) ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.update();
                bullet.draw();

                // Remove bullets that go off-screen
                if (bullet.y < 0) {
                    bullets.splice(i, 1);
                }
            }

            // --- Alien Bullet Updates ---
            for (let i = alienBullets.length - 1; i >= 0; i--) {
                const alienBullet = alienBullets[i];
                alienBullet.update();
                alienBullet.draw();

                // Check collision with player
                if (checkCollision(player, alienBullet)) {
                    player.takeDamage(alienBullet.damage);
                    alienBullets.splice(i, 1);
                    continue;
                }

                // Remove bullets that go off-screen
                if (alienBullet.y > canvas.height) {
                    alienBullets.splice(i, 1);
                }
            }

            // --- Boss Laser Updates ---
            for (let i = bossLasers.length - 1; i >= 0; i--) {
                const laser = bossLasers[i];
                laser.update(); // Just for fading logic
                laser.draw();

                // Check collision with player (laser hits regardless of position)
                if (Date.now() - laser.startTime < 100 && checkCollision(player, laser)) { // Only deal damage once at the start of the laser
                    player.takeDamage(laser.damage);
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, `-${laser.damage} HP (Laser)`, 'red'));
                }

                // Remove laser after its duration
                if (Date.now() - laser.startTime > laser.duration) {
                    bossLasers.splice(i, 1);
                }
            }


            // --- Wave Management & Alien Spawning ---
            // Check if a new wave should start (all aliens from previous wave destroyed or no boss)
            if (!boss && aliensDestroyedInWave >= ALIENS_PER_WAVE && aliens.length === 0 && aliensSpawnedInWave >= ALIENS_PER_WAVE) {
                currentWave++;
                aliensSpawnedInWave = 0;
                aliensDestroyedInWave = 0;
                inGameMessages.push(new InGameMessage(canvas.width / 2, canvas.height / 2, `Wave ${currentWave} Incoming!`, 'lightblue', 2500));
            }

            // Spawn boss on boss wave, if not already active and current wave is a boss wave and no regular aliens left
            if (currentWave % BOSS_WAVE_INTERVAL === 0 && currentWave > 0 && !boss && aliens.length === 0 && aliensSpawnedInWave === 0) {
                boss = new Boss(canvas.width / 2 - 50, -100, Math.floor(currentWave / BOSS_WAVE_INTERVAL));
                inGameMessages.push(new InGameMessage(canvas.width / 2, canvas.height / 2, "BOSS APPROACHES!", 'orange', 3000));
            } else if (!boss && aliensSpawnedInWave < ALIENS_PER_WAVE && currentTime - lastAlienSpawnTime > alienSpawnInterval) {
                // Spawn regular aliens for current wave, only if no boss is active
                const alienX = Math.random() * (canvas.width - 40);
                aliens.push(new Alien(alienX, -40, currentWave)); // Alien level based on current wave
                lastAlienSpawnTime = currentTime;
                aliensSpawnedInWave++;

                // Gradually increase game speed and decrease spawn interval
                // More aggressive scaling for game speed multiplier
                gameSpeedMultiplier += 0.002;
                alienSpawnInterval = Math.max(200, alienSpawnInterval - 5); // Min interval 200ms
            }


            // --- Alien Updates ---
            for (let i = aliens.length - 1; i >= 0; i--) {
                const alien = aliens[i];
                alien.update();
                alien.draw();

                // Check collision with player
                if (checkCollision(player, alien)) {
                    player.takeDamage(alien.attackDamage * 5); // More damage for direct collision
                    aliens.splice(i, 1); // Remove alien
                    aliensDestroyedInWave++;
                    continue; // Skip to next alien
                }
                // Solar Flame effect: player collides with alien
                if (activeEffects.solarFlame && checkCollision(player, alien)) {
                    if (alien.takeDamage(player.firepower * 0.5)) { // Solar flame deals half player's firepower
                        score += alien.scoreValue;
                        gold += alien.goldValue;
                        aliensDestroyedInWave++;
                        coins.push(new Coin(alien.x + alien.width / 2 - 12.5, alien.y + alien.height / 2 - 12.5, alien.goldValue));
                        aliens.splice(i, 1);
                        updateUI();
                        checkUpgradeButtonStates();
                        updateItemDisplay();
                    }
                }
            }

            // --- Boss Logic ---
            if (boss) {
                boss.update();
                boss.draw();
            }

            // --- Coin Updates ---
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.update();
                coin.draw();

                // Check collision with player to collect coin
                if (checkCollision(player, coin)) {
                    gold += coin.value;
                    coins.splice(i, 1); // Remove coin
                    updateUI();
                    checkUpgradeButtonStates(); // Recheck upgrade buttons after collecting gold
                    updateItemDisplay(); // Recheck item buttons after collecting gold
                    inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, `+${coin.value} Gold!`, 'gold'));
                    continue;
                }

                // Remove coins that go off-screen
                if (coin.y > canvas.height) {
                    coins.splice(i, 1);
                }
            }

            // --- Power-up Spawning ---
            const POWERUP_TYPES = ['health', 'invincibility', 'plasma_blaster', 'hyper_surge', 'magnetron_pull', 'solar_flame', 'repair_drone', 'frost_pulse'];
            if (Math.random() < 0.001 && powerups.length < 3 && !boss) { // Higher chance to spawn power-up, max 3 on screen
                const powerUpX = Math.random() * (canvas.width - 30);
                const randomType = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
                powerups.push(new PowerUp(powerUpX, -30, randomType));
            }

            // --- Power-up Updates ---
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.update();
                powerup.draw();

                // Check collision with player
                if (checkCollision(player, powerup)) {
                    powerup.applyEffect();
                    powerups.splice(i, 1);
                    continue;
                }

                // Remove power-ups that go off-screen
                if (powerup.y > canvas.height) {
                    powerups.splice(i, 1);
                }
            }


            // --- Collision Detection (Bullets vs Aliens/Boss) ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                let bulletHit = false;

                // Check against boss first
                if (boss && checkCollision(bullet, boss)) {
                    bullets.splice(i, 1); // Remove bullet
                    if (boss.takeDamage(bullet.damage)) {
                        score += boss.scoreValue;
                        gold += boss.goldValue;
                        coins.push(new Coin(boss.x + boss.width / 2 - 12.5, boss.y + boss.height / 2 - 12.5, boss.goldValue));
                        boss = null; // Boss destroyed
                        // After boss, immediately set flags to trigger next wave
                        aliensDestroyedInWave = ALIENS_PER_WAVE;
                        aliensSpawnedInWave = ALIENS_PER_WAVE;
                        inGameMessages.push(new InGameMessage(canvas.width / 2, canvas.height / 2, "BOSS DEFEATED!", 'gold', 3000));
                    }
                    bulletHit = true;
                }

                if (!bulletHit) {
                    for (let j = aliens.length - 1; j >= 0; j--) {
                        const alien = aliens[j];

                        if (checkCollision(bullet, alien)) {
                            bullets.splice(i, 1); // Remove bullet
                            if (alien.takeDamage(bullet.damage)) {
                                // Alien destroyed
                                score += alien.scoreValue;
                                gold += alien.goldValue;
                                aliensDestroyedInWave++; // Increment destroyed count
                                // Spawn a coin at alien's position
                                coins.push(new Coin(alien.x + alien.width / 2 - 12.5, alien.y + alien.height / 2 - 12.5, alien.goldValue));
                                aliens.splice(j, 1); // Remove alien
                                updateUI();
                                checkUpgradeButtonStates();
                                updateItemDisplay();
                            }
                            bulletHit = true;
                            break; // Bullet hit an alien, no need to check other aliens for this bullet
                        }
                    }
                }
            }

            // --- In-Game Messages Update ---
            for (let i = inGameMessages.length - 1; i >= 0; i--) {
                const msg = inGameMessages[i];
                msg.update();
                msg.draw();
                if (msg.alpha <= 0) {
                    inGameMessages.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop); // Continue the loop
        }

        /**
         * Checks for collision between two rectangular objects.
         * Assumes objects have x, y, width, height properties.
         * @param {object} obj1
         * @param {object} obj2
         * @returns {boolean} True if collision occurs, false otherwise.
         */
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        /**
         * Updates the score, gold, and health displays.
         */
        function updateUI() {
            scoreDisplay.textContent = score;
            goldDisplay.textContent = gold;
            healthDisplay.textContent = player.health;
        }

        /**
         * Displays a message in the message box (for main menu/non-gameplay events).
         * @param {string} text The message to display.
         * @param {string} type 'info', 'success', 'warning', 'danger' for styling.
         */
        function showMessage(text, type = 'info') {
            messageBox.textContent = text;
            messageBox.className = 'message-box show'; // Reset classes
            if (type === 'success') {
                messageBox.style.backgroundColor = '#c6f6d5';
                messageBox.style.borderColor = '#68d391';
                messageBox.style.color = '#276749';
            } else if (type === 'warning') {
                messageBox.style.backgroundColor = '#fefcbf';
                messageBox.style.borderColor = '#fbd38d';
                messageBox.style.color = '#975a16';
            } else if (type === 'danger') {
                messageBox.style.backgroundColor = '#fed7d7';
                messageBox.style.borderColor = '#fc8181';
                messageBox.style.color = '#9b2c2c';
            } else { // info
                messageBox.style.backgroundColor = '#bee3f8';
                messageBox.style.borderColor = '#63b3ed';
                messageBox.style.color = '#2c5282';
            }
            // Hide after a few seconds
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }

        /**
         * Calculates the cost of an individual upgrade based on its type and current level.
         * @param {string} type The type of upgrade (e.g., 'health', 'firepower').
         * @returns {number} The calculated cost.
         */
        function getIndividualUpgradeCost(type) {
            return Math.floor(UPGRADE_BASE_COST[type] * Math.pow(UPGRADE_COST_MULTIPLIER, upgradeLevels[type]));
        }

        /**
         * Updates the cost displayed on individual upgrade buttons.
         */
        function updateUpgradeButtonCosts() {
            healthCostDisplay.textContent = upgradeLevels.health < MAX_INDIVIDUAL_UPGRADE_LEVEL ? getIndividualUpgradeCost('health') : 'MAX';
            firepowerCostDisplay.textContent = upgradeLevels.firepower < MAX_INDIVIDUAL_UPGRADE_LEVEL ? getIndividualUpgradeCost('firepower') : 'MAX';
            speedCostDisplay.textContent = upgradeLevels.speed < MAX_INDIVIDUAL_UPGRADE_LEVEL ? getIndividualUpgradeCost('speed') : 'MAX';
            sizeCostDisplay.textContent = upgradeLevels.size < MAX_INDIVIDUAL_UPGRADE_LEVEL ? getIndividualUpgradeCost('size') : 'MAX';
            fireRateCostDisplay.textContent = upgradeLevels.fireRate < MAX_INDIVIDUAL_UPGRADE_LEVEL ? getIndividualUpgradeCost('fireRate') : 'MAX';

            healthLevelDisplay.textContent = `(${upgradeLevels.health}/${MAX_INDIVIDUAL_UPGRADE_LEVEL})`;
            firepowerLevelDisplay.textContent = `(${upgradeLevels.firepower}/${MAX_INDIVIDUAL_UPGRADE_LEVEL})`;
            speedLevelDisplay.textContent = `(${upgradeLevels.speed}/${MAX_INDIVIDUAL_UPGRADE_LEVEL})`;
            sizeLevelDisplay.textContent = `(${upgradeLevels.size}/${MAX_INDIVIDUAL_UPGRADE_LEVEL})`;
            fireRateLevelDisplay.textContent = `(${upgradeLevels.fireRate}/${MAX_INDIVIDUAL_UPGRADE_LEVEL})`;

            // Ship tier upgrade cost
            const nextShipTier = currentShipTier + 1;
            if (nextShipTier < SHIP_TIERS.length) {
                shipTierCostDisplay.textContent = SHIP_TIERS[nextShipTier].cost;
                upgradeShipTierBtn.disabled = gold < SHIP_TIERS[nextShipTier].cost;
            } else {
                shipTierCostDisplay.textContent = 'MAX';
                upgradeShipTierBtn.disabled = true;
            }
        }

        /**
         * Checks and updates the enabled/disabled state of upgrade buttons.
         */
        function checkUpgradeButtonStates() {
            upgradeHealthBtn.disabled = gold < getIndividualUpgradeCost('health') || upgradeLevels.health >= MAX_INDIVIDUAL_UPGRADE_LEVEL;
            upgradeFirepowerBtn.disabled = gold < getIndividualUpgradeCost('firepower') || upgradeLevels.firepower >= MAX_INDIVIDUAL_UPGRADE_LEVEL;
            upgradeSpeedBtn.disabled = gold < getIndividualUpgradeCost('speed') || upgradeLevels.speed >= MAX_INDIVIDUAL_UPGRADE_LEVEL;
            upgradeSizeBtn.disabled = gold < getIndividualUpgradeCost('size') || upgradeLevels.size >= MAX_INDIVIDUAL_UPGRADE_LEVEL;
            upgradeFireRateBtn.disabled = gold < getIndividualUpgradeCost('fireRate') || upgradeLevels.fireRate >= MAX_INDIVIDUAL_UPGRADE_LEVEL;

            updateUpgradeButtonCosts(); // Ensure costs are updated too
        }

        /**
         * Applies all current upgrades to the player.
         * This function is called at the start of the game and after each upgrade.
         */
        function applyUpgrades() {
            const currentTierData = SHIP_TIERS[currentShipTier];

            // Apply base stats from current ship tier
            player.baseSpeed = currentTierData.baseSpeed;
            player.baseFirepower = currentTierData.baseFirepower;
            player.baseFireRate = currentTierData.baseFireRate;
            player.baseHealth = currentTierData.baseHealth;
            player.baseWidth = currentTierData.baseWidth;
            player.baseHeight = currentTierData.baseHeight;

            // Reset player stats to current tier's base stats
            player.speed = player.baseSpeed;
            player.firepower = player.baseFirepower;
            player.fireRate = player.baseFireRate;
            player.maxHealth = player.baseHealth;
            player.width = player.baseWidth;
            player.height = player.baseHeight;
            player.image = loadedAssets[currentTierData.image]; // Update player image

            // Apply individual health upgrades
            player.maxHealth += upgradeLevels.health * 100; // +100 max health per level
            player.heal(upgradeLevels.health * 100); // Also heal by the amount of max health gained

            // Apply individual firepower upgrades
            player.firepower += upgradeLevels.firepower * 10; // +10 damage per level

            // Apply individual speed upgrades
            player.speed += upgradeLevels.speed * 1; // +1 speed per level

            // Apply individual size upgrades (visual and hitbox)
            player.width = player.baseWidth + (upgradeLevels.size * 5); // +5 width per level
            player.height = player.baseHeight + (upgradeLevels.size * 5); // +5 height per level

            // Apply individual fire rate upgrades (decrease fireRate for faster shooting)
            player.fireRate = Math.max(50, player.baseFireRate - (upgradeLevels.fireRate * 30)); // -30ms per level

            // Ensure player's current health doesn't exceed new max health
            player.health = Math.min(player.health, player.maxHealth);

            updateUI();
            updateShipDisplay(); // Update ship display in upgrade section
        }

        /**
         * Updates the ship display in the upgrade section.
         */
        let previewShipTier = 0; // The ship tier currently being previewed
        function updateShipDisplay() {
            const shipData = SHIP_TIERS[previewShipTier];
            currentShipImage.src = shipData.image;
            currentShipName.textContent = shipData.name;
            shipBaseHealth.textContent = shipData.baseHealth;
            shipBaseFirepower.textContent = shipData.baseFirepower;
            shipBaseSpeed.textContent = shipData.baseSpeed;
            shipBaseSize.textContent = shipData.baseWidth + 'x' + shipData.baseHeight; // Display width x height

            // Enable/disable navigation buttons
            prevShipBtn.disabled = previewShipTier === 0;
            nextShipBtn.disabled = previewShipTier === SHIP_TIERS.length - 1;

            // Show upgrade button if previewed ship is the next tier and not maxed
            if (previewShipTier === currentShipTier + 1 && currentShipTier < SHIP_TIERS.length - 1) {
                upgradeShipTierBtn.style.display = 'block';
                shipTierCostDisplay.textContent = SHIP_TIERS[previewShipTier].cost;
                upgradeShipTierBtn.disabled = gold < SHIP_TIERS[previewShipTier].cost;
            } else {
                upgradeShipTierBtn.style.display = 'none';
            }

            // If the previewed ship is the current ship, hide upgrade button
            if (previewShipTier === currentShipTier) {
                upgradeShipTierBtn.style.display = 'none';
            }
            // If the previewed ship is already max tier, show MAX
            if (currentShipTier === SHIP_TIERS.length - 1) {
                upgradeShipTierBtn.style.display = 'block'; // Show button to indicate max
                shipTierCostDisplay.textContent = 'MAX';
                upgradeShipTierBtn.disabled = true;
            }
        }

        /**
         * Updates the item counts and button states in the UI.
         */
        function updateItemDisplay() {
            cloneCostDisplay.textContent = ITEMS.clone.cost;
            cloneCountDisplay.textContent = inventory.clone;
            buyCloneBtn.disabled = gold < ITEMS.clone.cost;
            useCloneBtn.disabled = inventory.clone === 0 || activeEffects.clone; // Disable if no stock or effect active

            shieldCostDisplay.textContent = ITEMS.shield.cost;
            shieldCountDisplay.textContent = inventory.shield;
            buyShieldBtn.disabled = gold < ITEMS.shield.cost;
            useShieldBtn.disabled = inventory.shield === 0 || activeEffects.shield;

            bombCostDisplay.textContent = ITEMS.bomb.cost;
            bombCountDisplay.textContent = inventory.bomb;
            buyBombBtn.disabled = gold < ITEMS.bomb.cost;
            useBombBtn.disabled = inventory.bomb === 0; // Bomb is instant, no active effect check

            timeWarpCostDisplay.textContent = ITEMS.timeWarp.cost;
            timeWarpCountDisplay.textContent = inventory.timeWarp;
            buyTimeWarpBtn.disabled = gold < ITEMS.timeWarp.cost;
            useTimeWarpBtn.disabled = inventory.timeWarp === 0 || activeEffects.timeWarp;
        }

        // --- Event Listeners ---

        // Keyboard input for player movement
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            // Prevent default spacebar action (scrolling)
            if (e.code === 'Space') {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Touch input for player movement (simplified)
        let touchStartX = 0;
        let touchCurrentX = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length > 0) {
                touchStartX = e.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length > 0) {
                touchCurrentX = e.touches[0].clientX;
                const deltaX = touchCurrentX - touchStartX;

                // Adjust player position based on touch movement
                if (gameActive) {
                    player.x += deltaX * 0.8; // Adjust sensitivity
                    // Keep player within bounds
                    if (player.x < 0) player.x = 0;
                    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                }
                touchStartX = touchCurrentX; // Update start for continuous movement
            }
        });

        canvas.addEventListener('touchend', () => {
            // No specific action on touchend for continuous movement
        });


        // Start Game button
        startButton.addEventListener('click', startGame);

        // Upgrade buttons
        upgradeHealthBtn.addEventListener('click', () => {
            const cost = getIndividualUpgradeCost('health');
            if (gold >= cost && upgradeLevels.health < MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                gold -= cost;
                upgradeLevels.health++;
                applyUpgrades();
                updateUpgradeButtonCosts();
                checkUpgradeButtonStates();
                updateUI();
                showMessage(`Health upgraded! Current Max Health: ${player.maxHealth}.`, 'success');
            } else if (upgradeLevels.health >= MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                showMessage(`Health is already MAX level!`, 'info');
            } else {
                showMessage(`Not enough gold for Health upgrade! Need ${cost - gold} more.`, 'warning');
            }
        });

        upgradeFirepowerBtn.addEventListener('click', () => {
            const cost = getIndividualUpgradeCost('firepower');
            if (gold >= cost && upgradeLevels.firepower < MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                gold -= cost;
                upgradeLevels.firepower++;
                applyUpgrades();
                updateUpgradeButtonCosts();
                checkUpgradeButtonStates();
                updateUI();
                showMessage(`Firepower upgraded! Current Damage: ${player.firepower}.`, 'success');
            } else if (upgradeLevels.firepower >= MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                showMessage(`Firepower is already MAX level!`, 'info');
            } else {
                showMessage(`Not enough gold for Firepower upgrade! Need ${cost - gold} more.`, 'warning');
            }
        });

        upgradeSpeedBtn.addEventListener('click', () => {
            const cost = getIndividualUpgradeCost('speed');
            if (gold >= cost && upgradeLevels.speed < MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                gold -= cost;
                upgradeLevels.speed++;
                applyUpgrades();
                updateUpgradeButtonCosts();
                checkUpgradeButtonStates();
                updateUI();
                showMessage(`Speed upgraded! Current Speed: ${player.speed}.`, 'success');
            } else if (upgradeLevels.speed >= MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                showMessage(`Speed is already MAX level!`, 'info');
            } else {
                showMessage(`Not enough gold for Speed upgrade! Need ${cost - gold} more.`, 'warning');
            }
        });

        upgradeSizeBtn.addEventListener('click', () => {
            const cost = getIndividualUpgradeCost('size');
            if (gold >= cost && upgradeLevels.size < MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                gold -= cost;
                upgradeLevels.size++;
                applyUpgrades();
                updateUpgradeButtonCosts();
                checkUpgradeButtonStates();
                updateUI();
                showMessage(`Spaceship size upgraded! You're getting bigger!`, 'success');
            } else if (upgradeLevels.size >= MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                showMessage(`Size is already MAX level!`, 'info');
            } else {
                showMessage(`Not enough gold for Size upgrade! Need ${cost - gold} more.`, 'warning');
            }
        });

        upgradeFireRateBtn.addEventListener('click', () => {
            const cost = getIndividualUpgradeCost('fireRate');
            if (gold >= cost && upgradeLevels.fireRate < MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                gold -= cost;
                upgradeLevels.fireRate++;
                applyUpgrades();
                updateUpgradeButtonCosts();
                checkUpgradeButtonStates();
                updateUI();
                showMessage(`Fire Rate upgraded! Current Delay: ${player.fireRate}ms.`, 'success');
            } else if (upgradeLevels.fireRate >= MAX_INDIVIDUAL_UPGRADE_LEVEL) {
                showMessage(`Fire Rate is already MAX level!`, 'info');
            } else {
                showMessage(`Not enough gold for Fire Rate upgrade! Need ${cost - gold} more.`, 'warning');
            }
        });

        upgradeShipTierBtn.addEventListener('click', () => {
            const nextShipTier = currentShipTier + 1;
            if (nextShipTier < SHIP_TIERS.length) {
                const cost = SHIP_TIERS[nextShipTier].cost;
                if (gold >= cost) {
                    gold -= cost;
                    currentShipTier = nextShipTier;
                    // Reset individual upgrades when upgrading ship tier
                    upgradeLevels = { health: 0, firepower: 0, speed: 0, size: 0, fireRate: 0 };
                    applyUpgrades();
                    updateUpgradeButtonCosts();
                    checkUpgradeButtonStates();
                    updateUI();
                    previewShipTier = currentShipTier; // Reset preview to current ship
                    updateShipDisplay();
                    showMessage(`Upgraded to ${SHIP_TIERS[currentShipTier].name}! All individual upgrades reset.`, 'success');
                } else {
                    showMessage(`Not enough gold to upgrade to ${SHIP_TIERS[nextShipTier].name}! Need ${cost - gold} more.`, 'warning');
                }
            } else {
                showMessage("You have the best ship available!", 'info');
            }
        });

        // Ship navigation buttons
        prevShipBtn.addEventListener('click', () => {
            if (previewShipTier > 0) {
                previewShipTier--;
                updateShipDisplay();
            }
        });

        nextShipBtn.addEventListener('click', () => {
            if (previewShipTier < SHIP_TIERS.length - 1) {
                previewShipTier++;
                updateShipDisplay();
            }
        });

        // Redeem code logic
        redeemCodeBtn.addEventListener('click', () => {
            const code = redeemCodeInput.value.trim().toUpperCase();
            if (code === "RAAJ") {
                gold += 1000;
                showMessage("Code 'RAAJ' redeemed! You received 1000 gold!", 'success');
                redeemCodeInput.value = '';
            } else if (code === "TONY") {
                gold += 90000;
                showMessage("Code 'TONY' redeemed! You received 90000 gold! You are rich!", 'success');
                redeemCodeInput.value = '';
            } else {
                showMessage("Invalid redeem code.", 'danger');
            }
            updateUI();
            checkUpgradeButtonStates();
            updateItemDisplay();
        });

        // Item purchase buttons
        buyCloneBtn.addEventListener('click', () => { buyItem('clone'); });
        buyShieldBtn.addEventListener('click', () => { buyItem('shield'); });
        buyBombBtn.addEventListener('click', () => { buyItem('bomb'); });
        buyTimeWarpBtn.addEventListener('click', () => { buyItem('timeWarp'); });

        function buyItem(itemType) {
            const item = ITEMS[itemType];
            if (gold >= item.cost) {
                gold -= item.cost;
                inventory[itemType]++;
                updateUI();
                updateItemDisplay();
                showMessage(`Bought ${itemType.charAt(0).toUpperCase() + itemType.slice(1)}!`, 'success');
            } else {
                showMessage(`Not enough gold to buy ${itemType}! Need ${item.cost - gold} more.`, 'warning');
            }
        }

        // Item use buttons
        useCloneBtn.addEventListener('click', () => { useItem('clone'); });
        useShieldBtn.addEventListener('click', () => { useItem('shield'); });
        useBombBtn.addEventListener('click', () => { useItem('bomb'); });
        useTimeWarpBtn.addEventListener('click', () => { useItem('timeWarp'); });

        function useItem(itemType) {
            if (inventory[itemType] > 0) {
                inventory[itemType]--;
                updateItemDisplay();
                const DURATION = 7000; // Consistent duration for items
                if (itemType === 'clone') {
                    if (!activeEffects.clone) { // Only activate if not already active
                        activeEffects.clone = true;
                        playerClones.push(new PlayerClone(SHIP_TIERS[currentShipTier], -player.width - 10)); // Left clone
                        playerClones.push(new PlayerClone(SHIP_TIERS[currentShipTier], player.width + 10));  // Right clone
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Clone Activated!", 'lime'));
                        clearTimeout(effectTimers.clone);
                        effectTimers.clone = setTimeout(() => {
                            activeEffects.clone = false;
                            playerClones = []; // Remove clones
                            inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Clone Ended!", 'white'));
                            updateItemDisplay(); // Re-enable use button
                        }, DURATION);
                    } else {
                        showMessage("Clone is already active!", 'info');
                        inventory[itemType]++; // Return item if already active
                        updateItemDisplay();
                    }
                } else if (itemType === 'shield') {
                    if (!activeEffects.shield) {
                        activeEffects.shield = true;
                        player.setInvincibility(DURATION); // Re-use player's invincibility logic
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Shield Activated!", 'blue'));
                        clearTimeout(effectTimers.shield);
                        effectTimers.shield = setTimeout(() => {
                            activeEffects.shield = false;
                            player.isInvincible = false; // Ensure invincibility is off
                            inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Shield Expired!", 'white'));
                            updateItemDisplay(); // Re-enable use button
                        }, DURATION);
                    } else {
                        showMessage("Shield is already active!", 'info');
                        inventory[itemType]++;
                        updateItemDisplay();
                    }
                } else if (itemType === 'bomb') {
                    aliens = []; // Clear all aliens
                    alienBullets = []; // Clear all alien bullets
                    if (boss) {
                        score += boss.scoreValue;
                        gold += boss.goldValue;
                        coins.push(new Coin(boss.x + boss.width / 2 - 12.5, boss.y + boss.height / 2 - 12.5, boss.goldValue));
                        boss = null;
                        inGameMessages.push(new InGameMessage(canvas.width / 2, canvas.height / 2, "BOMB! ALL ENEMIES CLEARED!", 'red', 2000));
                        updateUI();
                        checkUpgradeButtonStates();
                        updateItemDisplay();
                    } else {
                        inGameMessages.push(new InGameMessage(canvas.width / 2, canvas.height / 2, "BOMB! ALL ALIENS CLEARED!", 'red', 2000));
                    }
                } else if (itemType === 'timeWarp') {
                    if (!activeEffects.timeWarp) {
                        activeEffects.timeWarp = true;
                        inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Time Warp Activated!", 'purple'));
                        clearTimeout(effectTimers.timeWarp);
                        effectTimers.timeWarp = setTimeout(() => {
                            activeEffects.timeWarp = false;
                            inGameMessages.push(new InGameMessage(player.x + player.width / 2, player.y, "Time Warp Ended!", 'white'));
                            updateItemDisplay(); // Re-enable use button
                        }, DURATION);
                    } else {
                        showMessage("Time Warp is already active!", 'info');
                        inventory[itemType]++;
                        updateItemDisplay();
                    }
                }
            } else {
                showMessage(`No ${itemType} left! Buy more.`, 'warning');
            }
        }


        // --- Initial Setup ---
        window.onload = function() {
            preloadAssets().then(() => {
                // Hide preloader with a slight delay for effect
                setTimeout(() => {
                    preloader.classList.add('preloader-hidden');
                    // Initialize game after preloader hides
                    setTimeout(() => {
                        preloader.style.display = 'none';
                        initializeGame();
                    }, 1000); // Wait for transition to finish
                }, 1000); // Show preloader for at least 1 second
            });
        };
    </script>
</body>
</html>
